<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>DL</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="sourceCode" id="cb1"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE InstanceSigs #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">DL</span> <span class="kw">where</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Applicative</span> ((&lt;|&gt;))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Monad</span> (foldM)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Kind</span> (<span class="dt">Type</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Test.QuickCheck</span> (</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Arbitrary</span> (<span class="op">..</span>),</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Gen</span>,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Property</span>,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     forAllShrink,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     (<span class="op">===</span>), discard, forAllShrinkShow,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    )</span></code></pre></div>
<p>The goal of this document is to provide a gentle introduction to
<em>Dynamic Logic</em>, a form of modal logic that is used within
<code>quickcheck-dynamic</code>. The intention is to provide an
intuition of how things work within the library on a simpler version of
the logic.</p>
<p>Dynamic Logic DL – for short – formulas give users the ability to
express and tests <em>liveness</em> and <em>safety</em> properties about
their code <em>independently</em> from the actual state-machine model
and implementation. Put it differently, DL formulas allow a user to
<em>restrict</em> the state space of a model and provide an <em>Embedded
Domain Specific Language</em> to define composable expressions
representing some fragment of a larger state.</p>
<p>In <code>quickcheck-dynamic</code>, <a
href="https://github.com/input-output-hk/quickcheck-dynamic/blob/f7ae1a47c255520db1f817c919f1013ccede050d/quickcheck-dynamic/src/Test/QuickCheck/DynamicLogic.hs#L9"><code>DynamicLogic</code></a>
is exposed through a monadic interface which makes it simpler to write
formulas, and, more importantly, provides variables and universal
quantification over values.</p>
<h1 id="propositional-dynamic-logic">Propositional Dynamic Logic</h1>
<p>This follows the presentation from the book <a
href="https://mitpress.mit.edu/9780262527668/dynamic-logic/">Dynamic
Logic</a> by Harel, Kozen and Tiuryn, in particular from p.164 on. Those
<a
href="https://www.cs.cmu.edu/~fp/courses/15816-s10/lectures/19-PDL.pdf">lecture
notes</a> have also been useful when preparing these notes.</p>
<h2 id="syntax">Syntax</h2>
<h3 id="propositions">Propositions</h3>
<p>This is the <code>Prop</code>ositional logic part of <em>Dynamic
Logic</em>. This type is parameterised by the type of atomic
propositions and atomic programs, whose semantics is given by a Kripke
structure.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Prop</span> f p <span class="kw">where</span></span></code></pre></div>
<p>Atomic propositions are drawn from the type <code>f</code>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Prop</span><span class="ot"> ::</span> f <span class="ot">-&gt;</span> <span class="dt">Prop</span> f p</span></code></pre></div>
<p>False and true are propositions. Note that <code>One</code> is not
strictly necessary but has been added for convenience purpose.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Zero</span><span class="ot"> ::</span> <span class="dt">Prop</span> f p</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">One</span><span class="ot"> ::</span> <span class="dt">Prop</span> f p</span></code></pre></div>
<p>The main logical combinator is implication. It’s well known that it’s
possible to reconstruct disjunction and conjunctions from
implication.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Imply</span><span class="ot"> ::</span> <span class="dt">Prop</span> f p <span class="ot">-&gt;</span> <span class="dt">Prop</span> f p <span class="ot">-&gt;</span> <span class="dt">Prop</span> f p</span></code></pre></div>
<p>The most interesting operator is the modal <em>necessity</em>
operator which informally states that some <code>Prop</code>osition must
<em>always</em> hold after the execution of some <code>Prog</code>ram.
The dual operator, <em>possibility</em>, which states some proposition
can hold after some program, could be derived but is impractical to work
with in the context of test case generations and verification.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Always</span><span class="ot"> ::</span> <span class="dt">Prog</span> f p <span class="ot">-&gt;</span> <span class="dt">Prop</span> f p <span class="ot">-&gt;</span> <span class="dt">Prop</span> f p</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<h3 id="programs">Programs</h3>
<p><code>Prog</code>rams are what makes the Dynamic Logic a modal logic,
obviously. This type is also parameterised by atomic propositions
<code>f</code> and atomic programs (aka. <em>actions</em>)
<code>p</code>.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Prog</span> f p <span class="kw">where</span></span></code></pre></div>
<p>The empty program, also called <em>skip</em> or represented by the
<span class="math inline">∅</span> symbol, represents termination of a
program execution. We could also define <code>Abort</code> or divergence
to represent non-termination or invalid execution.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Empty</span><span class="ot"> ::</span> <span class="dt">Prog</span> f p</span></code></pre></div>
<p>Every atomic program <code>p</code> is of course a program.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Prog</span><span class="ot"> ::</span> p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p</span></code></pre></div>
<p>Programs can be run in <em>sequence</em>, one after another</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Seq</span><span class="ot"> ::</span> <span class="dt">Prog</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p</span></code></pre></div>
<p>Or one or the other can be run, non deterministically.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Alt</span><span class="ot"> ::</span> <span class="dt">Prog</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p</span></code></pre></div>
<p>Programs can also be repeated, indefinitely, using an analog to the
Kleene star from regular lagnauges.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Star</span><span class="ot"> ::</span> <span class="dt">Prog</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p</span></code></pre></div>
<p>Finally, a program can be a <em>test</em> which does not change the
state of the system but either yields <em>skip</em> or <em>abort</em>
depending on the result of evaluating the given proposition.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Test</span><span class="ot"> ::</span> <span class="dt">Prop</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<h3 id="deriving-constructs">Deriving constructs</h3>
<p>Standard constructs from imperative programming can be define from
the basic combinators, like <code>if/then/else</code> or
<code>while</code> instructions:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt; ifThenElse ::</span> <span class="dt">Prop</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p <span class="ot">-&gt;</span> <span class="dt">Prog</span> f p</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> ifThenElse cond ifTrue ifFalse <span class="ot">=</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Alt</span> (<span class="dt">Seq</span> (<span class="dt">Test</span> cond) ifTrue)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       (<span class="dt">Seq</span> (<span class="dt">Test</span> (<span class="dt">Imply</span> cond <span class="dt">Zero</span>)) ifFalse)</span></code></pre></div>
<h2 id="semantics">Semantics</h2>
<p>The semantics of Dynamic Logic formulas is given by a <em>Kripke</em>
structure <span
class="math inline"><em>K</em> = (<em>W</em>,<em>ϕ</em>,<em>δ</em>)</span></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">Kripke</span> m w <span class="op">|</span> w <span class="ot">-&gt;</span> m <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">type</span> <span class="dt">Formula</span><span class="ot"> w ::</span> <span class="dt">Type</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">type</span> <span class="dt">Program</span><span class="ot"> w ::</span> <span class="dt">Type</span></span></code></pre></div>
<p>with <span class="math inline"><em>ϕ</em></span> giving an
interpretation of atomic propositions as a subset of <span
class="math inline"><em>W</em></span>. Note that this subset is here
defined through a characteristic function <code>w -&gt; Bool</code>.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   ϕ<span class="ot"> ::</span> <span class="dt">Formula</span> w <span class="ot">-&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>And <span class="math inline"><em>δ</em></span> giving an
interpretation of atomic programs. The usual presentation is to consider
<span class="math inline"><em>δ</em></span> as a relation over <span
class="math inline"><em>W</em></span>, by making the computation monadic
we provide some flexibility of interpretation: A function is
<code>m = Identity</code>, a partial function if <code>m = Maybe</code>,
a relation if <code>m = [w]</code> or anything else.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   δ<span class="ot"> ::</span> <span class="dt">Program</span> w <span class="ot">-&gt;</span> w <span class="ot">-&gt;</span> m w</span></code></pre></div>
<h3 id="satisfiability">Satisfiability</h3>
<p>Given some Kripke structure <span
class="math inline"><em>K</em></span>, a formula <code>f</code> is
<em>satisfied</em> in a state <code>s</code> denoted as <span
class="math inline"><em>K</em>, <em>s</em> ⊨ <em>f</em></span> if the
formula is true in the state <code>s</code>, which is defined
inductively over the structure of <code>f</code>.</p>
<p>Note that we need to limit the size of the formula to avoid infinite
recursion.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> satisfy</span></code></pre></div>
<p>Note that <code>satisfy</code> is defined here with atomic programs
defining <em>relations</em> over <code>s</code> and not functions, eg. a
given program <code>p</code> can have multiple possible state
outcomes.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;   ::</span> <span class="dt">Kripke</span> [] s</span></code></pre></div>
<p>The size parameter bounds the depth at which state is explored and
the formula is evaluated.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="ot">=&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>The formula to evaluate, <code>f</code> is a proposition dependent on
the atomic propositions and programs in <span
class="math inline"><em>K</em></span>.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="ot">-&gt;</span> <span class="dt">Prop</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s)</span></code></pre></div>
<p>The state in which to evaluate the formula.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="ot">-&gt;</span> s</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> satisfy k prop s <span class="ot">=</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">case</span> prop <span class="kw">of</span></span></code></pre></div>
<p>Atomic propositions are evaluated by the characteristic function
<span class="math inline"><em>ϕ</em></span>.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Prop</span> f <span class="ot">-&gt;</span> ϕ f s</span></code></pre></div>
<p>False, true, and implications are evaluated as expected for
propositional logic operators.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Zero</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">One</span> <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Imply</span> f g <span class="ot">-&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="fu">not</span> (satisfy (k <span class="op">-</span> <span class="dv">1</span>) f s) <span class="op">||</span> satisfy (k <span class="op">-</span> <span class="dv">1</span>) g s</span></code></pre></div>
<p>The <em>always</em> operator is evaluated by checking that the
proposition holds in <em>all</em> the states reachable from the current
state by executing the program <code>p</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Always</span> p f <span class="ot">-&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="kw">case</span> step k p s <span class="kw">of</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         [] <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         states <span class="ot">-&gt;</span> <span class="fu">all</span> (satisfy (k <span class="op">-</span> <span class="dv">1</span>) f) states</span></code></pre></div>
<p>The <code>step</code> function computes the set of states reachable
from the current state by executing the program <code>p</code>.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt; step ::</span> <span class="dt">Kripke</span> [] s</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="ot">=&gt;</span> <span class="dt">Int</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="ot">-&gt;</span> <span class="dt">Prog</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="ot">-&gt;</span> s</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="ot">-&gt;</span> [s]</span></code></pre></div>
<p>If the size limit is reached, the computation is considered “stuck”
and yields no reachable state.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> step <span class="dv">0</span> _ _ <span class="ot">=</span> []</span></code></pre></div>
<p>In other cases, reachable states are defined inductively over the
structure of the program.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> step k prog s <span class="ot">=</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">case</span> prog <span class="kw">of</span></span></code></pre></div>
<p>If program should stop, simply return the current state.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Empty</span> <span class="ot">-&gt;</span> [s]</span></code></pre></div>
<p>Atomic programs yield the result of the transition relation <span
class="math inline"><em>δ</em></span>.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Prog</span> p <span class="ot">-&gt;</span> δ p s</span></code></pre></div>
<p>Sequencing of programs is done by executing the first program and
then the second program on the resulting state(s).</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Seq</span> p q <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       s&#39; <span class="ot">&lt;-</span> step k p s</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       step k q s&#39;</span></code></pre></div>
<p>Non-deterministic choice is done by executing either the first or the
second program, with a bias towards the first program.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Alt</span> p q <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       step k p s <span class="op">&lt;|&gt;</span> step k q s</span></code></pre></div>
<p>Test programs are executed by checking if the proposition holds in
the current state and returning the current state if it does.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Test</span> f <span class="ot">-&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       [s <span class="op">|</span> satisfy (k <span class="op">-</span> <span class="dv">1</span>) f s]</span></code></pre></div>
<p>Finally, repetition of a program is done by iterating over the nested
program <code>k</code> times.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Star</span> p <span class="ot">-&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       foldM (<span class="fu">flip</span> <span class="op">$</span> step (k <span class="op">-</span> <span class="dv">1</span>)) s (<span class="fu">replicate</span> k p)</span></code></pre></div>
<h3 id="a-concrete-example">A “concrete” Example</h3>
<p>The following is a concrete example of some simple data types and
Kripke structure to evaluate the satisfaction of a formula, drawn from
p.170 of the book.</p>
<p>The system’s state is simply an enumeration of 3 different
states.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">S</span> <span class="ot">=</span> <span class="dt">U</span> <span class="op">|</span> <span class="dt">V</span> <span class="op">|</span> <span class="dt">W</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>There’s a single atomic program, <code>A</code>.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">P</span> <span class="ot">=</span> <span class="dt">A</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>The atomic propositions are simply a list of states and a proposition
is true iff reached state is included in the list.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">F</span> <span class="ot">=</span> [<span class="dt">S</span>]</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Kripke</span> [] <span class="dt">S</span> <span class="kw">where</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">type</span> <span class="dt">Formula</span> <span class="dt">S</span> <span class="ot">=</span> <span class="dt">F</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">type</span> <span class="dt">Program</span> <span class="dt">S</span> <span class="ot">=</span> <span class="dt">P</span></span></code></pre></div>
<div class="sourceCode" id="cb41"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   ϕ<span class="ot"> ::</span> <span class="dt">F</span> <span class="ot">-&gt;</span> <span class="dt">S</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   ϕ <span class="ot">=</span> <span class="fu">flip</span> <span class="fu">elem</span></span></code></pre></div>
<p>The transition relation is the only interesting part of the Kripke
structure.</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   δ<span class="ot"> ::</span> <span class="dt">P</span> <span class="ot">-&gt;</span> <span class="dt">S</span> <span class="ot">-&gt;</span> [<span class="dt">S</span>]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   δ <span class="dt">A</span> <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">U</span> <span class="ot">-&gt;</span> [<span class="dt">V</span>, <span class="dt">W</span>]</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">W</span> <span class="ot">-&gt;</span> [<span class="dt">V</span>]</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">V</span> <span class="ot">-&gt;</span> [<span class="dt">W</span>]</span></code></pre></div>
<p>Now, let’s define a simple formula to check if the state
<code>V</code> is reachable from the state <code>U</code> after
executing the program <code>A</code>.</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt; formula ::</span> <span class="dt">Prop</span> <span class="dt">F</span> <span class="dt">P</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> formula <span class="ot">=</span> <span class="dt">Always</span> (<span class="dt">Star</span> (<span class="dt">Prog</span> <span class="dt">A</span>)) (<span class="dt">Prop</span> [<span class="dt">V</span>,<span class="dt">W</span>])</span></code></pre></div>
<p>We can now check if the formula is satisfied in the state
<code>U</code> of the Kripke structure defined above within GHCi:</p>
<pre><code>$ satisfy 10 formula U
True</code></pre>
<h1 id="property-based-testing">Property-Based Testing</h1>
<p>Another way to look at the semantics of Dynamic Logic is to consider
it in the context of traces, that is finite sequences of programs. Here
formula’s meaning is the set of traces that satisfy the formula. This is
particularly useful in the context of property-based testing: Given some
Kripke structure and generators, we can generate traces and check if all
traces satisfy a given formula.</p>
<h2 id="checking-satisfiability">Checking satisfiability</h2>
<p>The basic property we want to check is the satisfiability of some
formula against arbitrary valid traces part of the Kripke structure. In
other words, we want to explore the states of the Kripke structure that
are reachable throughsome sequence of execution of programs, and check
if the formula holds for all of them.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> isSatisfiable</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;   ::</span> ( <span class="dt">Eq</span> s, <span class="dt">Show</span> s</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      , <span class="dt">Eq</span> (<span class="dt">Formula</span> s), <span class="dt">Show</span> (<span class="dt">Formula</span> s)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      , <span class="dt">Eq</span> (<span class="dt">Program</span> s), <span class="dt">Show</span> (<span class="dt">Program</span> s)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      , <span class="dt">Test.QuickCheck.Arbitrary</span> (<span class="dt">Program</span> s)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      , <span class="dt">Kripke</span> <span class="dt">Maybe</span> s)</span></code></pre></div>
<p>Given some initial state,</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">=&gt;</span> s</span></code></pre></div>
<p>A generator for traces,</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Test.QuickCheck.Gen</span> [<span class="dt">Program</span> s])</span></code></pre></div>
<p>and a formula to check,</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> <span class="dt">Prop</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> <span class="dt">Test.QuickCheck.Property</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> isSatisfiable i gen f <span class="ot">=</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   Test.QuickCheck.forAllShrink (gen i) Test.QuickCheck.shrink <span class="op">$</span> \trace <span class="ot">-&gt;</span></span></code></pre></div>
<p>It should hold that the formula evaluates to <code>True</code> given
the trace and the initial state.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     eval i f trace <span class="op">Test.QuickCheck.===</span> <span class="dt">One</span></span></code></pre></div>
<p>To do so, we need to <code>eval</code>uate a formula in a given state
against some trace, yielding a simpler formula until we reach atomic
propositions or ground truths.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> eval</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;   ::</span> (<span class="dt">Kripke</span> <span class="dt">Maybe</span> s, <span class="dt">Eq</span> s, <span class="dt">Show</span> s, <span class="dt">Show</span> (<span class="dt">Program</span> s), <span class="dt">Show</span> (<span class="dt">Formula</span> s))</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">=&gt;</span> s</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> <span class="dt">Prop</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> [<span class="dt">Program</span> s]</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> <span class="dt">Prop</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> eval s prop trace <span class="ot">=</span></span></code></pre></div>
<p>Evaluation proceeds recursively over the structure of the formula and
the trace.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">case</span> prop <span class="kw">of</span></span></code></pre></div>
<p>Atomic propositions should hold in the current state</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Prop</span> f <span class="ot">-&gt;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="kw">if</span> ϕ f s <span class="kw">then</span> <span class="dt">One</span> <span class="kw">else</span> <span class="dt">Zero</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Zero</span> <span class="ot">-&gt;</span> <span class="dt">Zero</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">One</span> <span class="ot">-&gt;</span> <span class="dt">One</span></span></code></pre></div>
<p>Implications follow the usual rules of logic</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Imply</span> f g <span class="ot">-&gt;</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="kw">let</span> f&#39; <span class="ot">=</span> eval s f trace</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>           g&#39; <span class="ot">=</span> eval s g trace</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        <span class="kw">in</span> <span class="kw">case</span> (f&#39;, g&#39;) <span class="kw">of</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>             (<span class="dt">Zero</span>, _) <span class="ot">-&gt;</span> <span class="dt">One</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>             (<span class="dt">One</span>, <span class="dt">One</span>) <span class="ot">-&gt;</span> <span class="dt">One</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>             (_, _) <span class="ot">-&gt;</span> <span class="dt">Zero</span></span></code></pre></div>
<p>The <em>always</em> operator requires advancing the state by
executing the program <code>p</code> and evaluating the formula
<code>f</code> in the resulting state, agains the resulting trace.</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">Always</span> p f <span class="ot">-&gt;</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="kw">case</span> match s trace p <span class="kw">of</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="dt">Right</span> (s&#39;, trace&#39;) <span class="ot">-&gt;</span> eval s&#39; f trace&#39;</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="dt">Left</span>{} <span class="ot">-&gt;</span> <span class="dt">Zero</span></span></code></pre></div>
<p>The match function advances the state by executing the program
<code>p</code>:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> match</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;   ::</span> (<span class="dt">Kripke</span> <span class="dt">Maybe</span> s, <span class="dt">Eq</span> s, <span class="dt">Show</span> s, <span class="dt">Show</span> (<span class="dt">Program</span> s), <span class="dt">Show</span> (<span class="dt">Formula</span> s))</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">=&gt;</span> s</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> [<span class="dt">Program</span> s]</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> <span class="dt">Prog</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s)</span></code></pre></div>
<p>Note match can fail if the program is not executable in the current
state, in which case it returns some error message and the remaining
trace.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">String</span>, [<span class="dt">Program</span> s]) (s, [<span class="dt">Program</span> s])</span></code></pre></div>
<p>The base case is when the trace is empty, in which case the program
should terminate which is only possible if the program is empty, or it
can be repeated indefinitely which includes the case where it’s not
repeated at all.</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> match s [] <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Right</span> (s, [])</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Star</span>{} <span class="ot">-&gt;</span> <span class="dt">Right</span> (s, [])</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   other <span class="ot">-&gt;</span> <span class="dt">Left</span> (<span class="st">&quot;empty trace with program &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> other, [])</span></code></pre></div>
<p>If the trace is not empty, we need to inductively walk through the
trace and the program structure:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> match s trace<span class="op">@</span>(a <span class="op">:</span> as) <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> (<span class="st">&quot;program should terminate&quot;</span>, trace)</span></code></pre></div>
<p>For atomic programs, we could check equality of the atomic programs
and advance the state if they matched, but we choose instead to check
equality of <em>observational behaviors</em> of the programs, eg.
whether or not the two programs yield the same state:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Prog</span> b <span class="ot">-&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="kw">case</span> (δ a s, δ b s) <span class="kw">of</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       (<span class="dt">Just</span> t, <span class="dt">Just</span> t&#39;)</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="op">|</span> t <span class="op">==</span> t&#39; <span class="ot">-&gt;</span> <span class="dt">Right</span> (t&#39;, as)</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       _other <span class="ot">-&gt;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="dt">Left</span> (<span class="st">&quot;unmatched atomic program, expected&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;, found &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> a, trace)</span></code></pre></div>
<p>Sequential execution is straightforward, simply feeding the new state
and trace to the next program</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Seq</span> p q <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     (s&#39;, trace&#39;) <span class="ot">&lt;-</span> match s trace p</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     match s&#39; trace&#39; q</span></code></pre></div>
<p>Non-deterministic choice is also straightforward, trying to match the
first program and if it fails, trying the second program. Note that we
cannot here use the <code>Alternative</code> operator
<code>(&lt;|&gt;)</code> as <code>Either e</code> is, somewhat
surprisingly in the case of an “error” monad, not an instance of
<code>Alternative</code>.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Alt</span> p q <span class="ot">-&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="kw">case</span> match s trace p <span class="kw">of</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="dt">Right</span> v <span class="ot">-&gt;</span> <span class="dt">Right</span> v</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="dt">Left</span>{} <span class="ot">-&gt;</span> match s trace q</span></code></pre></div>
<p>Repetition is also quite simple and terminates because the base case
(<code>Prog p</code>) consumes the head of the trace.</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Star</span> p&#39; <span class="ot">-&gt;</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="kw">case</span> match s trace p&#39; <span class="kw">of</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="dt">Right</span> (s&#39;, trace&#39;) <span class="ot">-&gt;</span> match s&#39; trace&#39; (<span class="dt">Star</span> p&#39;)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="dt">Left</span>{} <span class="ot">-&gt;</span> <span class="dt">Right</span> (s, trace)</span></code></pre></div>
<p>Finally, we can <code>Test</code> a formula whose result depends on
call to <code>eval</code> with current state and trace.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="dt">Test</span> f <span class="ot">-&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="kw">case</span> eval s f trace <span class="kw">of</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       <span class="dt">One</span> <span class="ot">-&gt;</span> <span class="dt">Right</span> (s, trace)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>       _other <span class="ot">-&gt;</span> <span class="dt">Left</span> (<span class="st">&quot;test failed&quot;</span>, trace)</span></code></pre></div>
<h3 id="example">Example</h3>
<p>The generator for our simple model is quite simple as there’s a
single action.</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Test.QuickCheck.Arbitrary</span> <span class="dt">P</span> <span class="kw">where</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   arbitrary <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">A</span></span></code></pre></div>
<p>However we need a different Kripke structure because we want it to
work in the <code>Maybe</code> monad, so let’s wrap <code>S</code> and
create the structure:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">S&#39;</span> <span class="ot">=</span> <span class="dt">S&#39;</span> {<span class="ot"> unS ::</span> <span class="dt">S</span> }</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<div class="sourceCode" id="cb66"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Kripke</span> <span class="dt">Maybe</span> <span class="dt">S&#39;</span> <span class="kw">where</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">type</span> <span class="dt">Formula</span> <span class="dt">S&#39;</span> <span class="ot">=</span> <span class="dt">F</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">type</span> <span class="dt">Program</span> <span class="dt">S&#39;</span> <span class="ot">=</span> <span class="dt">P</span></span></code></pre></div>
<div class="sourceCode" id="cb67"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   ϕ f <span class="ot">=</span> ϕ f <span class="op">.</span> unS</span></code></pre></div>
<div class="sourceCode" id="cb68"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   δ <span class="dt">A</span> <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">S&#39;</span> <span class="dt">U</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">S&#39;</span> <span class="dt">W</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">S&#39;</span> <span class="dt">V</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">S&#39;</span> <span class="dt">W</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>     <span class="dt">S&#39;</span> <span class="dt">W</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">S&#39;</span> <span class="dt">V</span></span></code></pre></div>
<p>Then we can run QuickCheck over our example formula:</p>
<pre><code>$ quickCheck $ isSatisfiable (S&#39; U)  (const arbitrary) formula
*** Failed! Falsified (after 1 test):
[]
Zero /= One</code></pre>
<p>Of course, the formula is wrong on an empty sequence of actions as we
are in state <code>U</code>, but if we start from state <code>V</code>
we can verify the property holds:</p>
<pre><code>quickCheck $ isSatisfiable (S&#39; V)  (const arbitrary) formula
+++ OK, passed 100 tests.</code></pre>
<h2 id="generating-valid-traces">Generating valid traces</h2>
<p>In practice, what we are interested in with Dynamic Logic formulas is
rather the converse of what we have done so far: Inferring the subset of
Kripke structure that’s a model for a given formula, for a given
“universe of discourse” consisting of the atomic propositions and
programs.</p>
<p><strong>NOTE</strong>: This implementation relies on
<code>discard</code> from the QuickCheck library to prune sequence of
programs which is annoying. It would be better to wrap generation in
some result type and keep generating upon failures, until some timeout
or limit is reached.</p>
<p>Our generator thus takes an initial state, a formula and output a
list of <code>Program</code> that satisfy this formula. If there’s no
such list, for example because some proposition is not valid in some
state, then the generated sequence is <code>discard</code>ed.</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt; generate ::</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="kw">forall</span> s<span class="op">.</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Kripke</span> <span class="dt">Maybe</span> s</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="ot">=&gt;</span> s</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="ot">-&gt;</span> <span class="dt">Prop</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="ot">-&gt;</span> <span class="dt">Gen</span> [<span class="dt">Program</span> s]</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> generate i <span class="ot">=</span> go i []</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   <span class="kw">where</span></span></code></pre></div>
<p>As expected, the generator proceeds recursively on the structure of
the proposition, accumulating a trace as it walks through the syntax
tree.</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;    go ::</span> s <span class="ot">-&gt;</span> [<span class="dt">Program</span> s] <span class="ot">-&gt;</span> <span class="dt">Prop</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s) <span class="ot">-&gt;</span>  <span class="dt">Gen</span> [<span class="dt">Program</span> s]</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    go s acc <span class="ot">=</span> \<span class="kw">case</span></span></code></pre></div>
<p>A formula that’s not verified in the current state discards its
accumulated trace, otherwise it yields it.</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Prop</span> f <span class="ot">-&gt;</span> <span class="kw">if</span> ϕ f s</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>                 <span class="kw">then</span> <span class="fu">pure</span> acc</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>                 <span class="kw">else</span> discard</span></code></pre></div>
<p>False and True and logical implications are handled as expected,
respectively discarding their trace, returning it or testing both
formulas with the same state.</p>
<p><strong>NOTE</strong>: <code>Imply</code> implementation is most
probably wrong…</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Zero</span> <span class="ot">-&gt;</span> discard</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">One</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> acc</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Imply</span> f g <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        tr <span class="ot">&lt;-</span> go s acc f</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        go s (acc <span class="op">&lt;&gt;</span> tr) g</span></code></pre></div>
<p>Modal necessity tries to make some progress from given program and
checks the result formula in the new state.</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Always</span> p f <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        (s&#39;, prog) <span class="ot">&lt;-</span> progress s p</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        go s&#39; (acc <span class="op">&lt;&gt;</span> prog) f</span></code></pre></div>
<p>Progress proceeds also structurally through a program’s
structure:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;    progress ::</span> s <span class="ot">-&gt;</span> <span class="dt">Prog</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s) <span class="ot">-&gt;</span> <span class="dt">Gen</span> (s, [<span class="dt">Program</span> s])</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>    progress s <span class="ot">=</span> \<span class="kw">case</span></span></code></pre></div>
<p>Empty program succeeds yielding an empty trace and unchanged
state.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> (s, [])</span></code></pre></div>
<p>An atomic program updates state and trace iff <span
class="math inline"><em>δ</em></span> is defined in the Kripke structure
for the current state and program.</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Prog</span> p <span class="ot">-&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        <span class="kw">case</span> δ p s <span class="kw">of</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> discard</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>          <span class="dt">Just</span> s&#39; <span class="ot">-&gt;</span> <span class="fu">pure</span> (s&#39;, [p])</span></code></pre></div>
<p>Sequence of programs accumulate state change and trace for both
executed programs.</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Seq</span> p q <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        (s&#39;, p&#39;) <span class="ot">&lt;-</span> progress s p</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        (s&#39;&#39;, q&#39;) <span class="ot">&lt;-</span> progress s&#39; q</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        <span class="fu">pure</span> (s&#39;&#39;, p&#39; <span class="op">&lt;&gt;</span> q&#39;)</span></code></pre></div>
<p>Choice is handled non-deterministically, flipping a coin and
selecting one of the branches to make progress. This assumes that should
one branch fail, the other one will ultimately be selected.</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Alt</span> p q <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        b <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        <span class="kw">if</span> b</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="kw">then</span> progress s p</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="kw">else</span> progress s q</span></code></pre></div>
<p>A test leaves the state unchanged and depends on the result of
evaluating the formula.</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Test</span> f <span class="ot">-&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        (s,) <span class="op">&lt;$&gt;</span> go s [] f</span></code></pre></div>
<p>Finally, iterative execution also flips a coin: If it fails, an empty
trace and unchanged state is returned, otherwise it progresses through
one step of the program and recursively calls itself with the
result.</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      <span class="dt">Star</span> p <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        b <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>        <span class="kw">if</span> b</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>          <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>            (s&#39;, p&#39;) <span class="ot">&lt;-</span> progress s p</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>            (s&#39;&#39;, p&#39;&#39;) <span class="ot">&lt;-</span> progress s&#39; (<span class="dt">Star</span> p)</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>            <span class="fu">pure</span> (s&#39;&#39;, p&#39; <span class="op">&lt;&gt;</span> p&#39;&#39;)</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>          <span class="kw">else</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>            <span class="fu">pure</span> (s, [])</span></code></pre></div>
<p>We can actually verify our generator is consistent with the given
formula, expressing that as a <code>Property</code>:</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt; generateConsistentWithEval ::</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         ( <span class="dt">Eq</span> s, <span class="dt">Show</span> s</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         , <span class="dt">Eq</span> (<span class="dt">Formula</span> s), <span class="dt">Show</span> (<span class="dt">Formula</span> s)</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         , <span class="dt">Eq</span> (<span class="dt">Program</span> s), <span class="dt">Show</span> (<span class="dt">Program</span> s)</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         , <span class="dt">Test.QuickCheck.Arbitrary</span> (<span class="dt">Program</span> s)</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         , <span class="dt">Kripke</span> <span class="dt">Maybe</span> s)</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="ot">=&gt;</span> s</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="ot">-&gt;</span> <span class="dt">Prop</span> (<span class="dt">Formula</span> s) (<span class="dt">Program</span> s)</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>         <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span> generateConsistentWithEval i f <span class="ot">=</span></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>   forAllShrinkShow (generate i f) shrink <span class="fu">show</span> <span class="op">$</span> \ trace <span class="ot">-&gt;</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a><span class="ot">&gt;</span>      eval i f trace <span class="op">Test.QuickCheck.===</span> <span class="dt">One</span></span></code></pre></div>
<p>Running this property gives us:</p>
<pre><code>$ Test.QuickCheck.quickCheck $ generateConsistentWithEval (S&#39; U) formula
+++ OK, passed 100 tests; 78 discarded.</code></pre>
</body>
</html>
